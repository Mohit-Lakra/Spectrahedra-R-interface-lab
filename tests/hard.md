# Hard test — R interface extension (Rvolesti)

## Goal

Make a small, user-facing extension in the R interface that reaches compiled code, and add a minimal test that proves the new option works.

## What I implemented (GeomScale/Rvolesti PR #37)

This PR adds an incremental “plumbing-first” Spectrahedron path for `volume()` while keeping the existing polytope/zonotope behavior unchanged.

### R side

- Introduced an S3 generic for `volume()`:

  - `volume <- function(body, ...) UseMethod("volume")`

- Kept existing behavior for non-spectrahedra in `volume.default()`:

  - routes to the existing compiled entry point used previously by `volume(...)`

- Added `volume.Spectrahedron()` with a strict `verbosity` argument:

  - `verbosity = 0L` → silent (no intentional output)
  - `verbosity = 1L` → coarse progress output
  - `verbosity = 2L` → debug output

  The method validates `verbosity` and then calls a dedicated native entry point for spectrahedra via `.Call()`.

> Note: `volume.Spectrahedron()` only uses the Spectrahedron-specific native symbol; it does not change or intercept the default volume pipeline.

### C++ side

- Added a small Rcpp-exported entry point `volume_spectrahedra(...)`:

  - consumes the R list of matrices and converts it to `std::vector<Eigen::MatrixXd>`
  - emits progress/debug banners using `Rprintf()` depending on `verbosity`
  - returns a deterministic placeholder result for now:
    - `volume = 2^dim`
    - `log_volume = log(volume)`

This implementation is intentionally a stub: the hard-test objective is to add a user-facing option, thread it through to compiled code, register the symbol correctly, and cover it with a focused test. The real spectrahedra volume estimator can replace the stub behind the same interface in follow-up work.

### Tests

- Added `tests/testthat/test_spectrahedron_volume.R`

The test:
- constructs a small 2×2 toy spectrahedron (two matrices)
- exercises `verbosity = 0L, 1L, 2L`
- checks:
  - the placeholder numeric result is consistent
  - progress output appears at verbosity 1
  - debug output appears at verbosity 2

The output checks use `capture.output()` because the C++ side prints via `Rprintf()` (stdout). Any messages emitted via `message()` would need `expect_message()` instead.

### Run only the new test file

```r
testthat::test_file("tests/testthat/test_spectrahedron_volume.R", load_package = "source")
```

### Why `testthat::test_file(...)` failed without `load_package`

If you run:

```r
testthat::test_file("tests/testthat/test_spectrahedron_volume.R")
```

testthat does not automatically load the package, so exported functions/classes (like `Spectrahedron()`) may not exist in that session. Using `load_package = "source"` (or running `devtools::test()`) ensures the package is loaded first.

## What I saw (local output)

- `devtools::test()` passed the full suite (including the new spectrahedron test).
- `testthat::test_file(...)` without loading the package failed because `Spectrahedron()` was not found.

## Files touched in the PR

- `R/volume.R`
- `NAMESPACE` (generated by roxygen2)
- `src/volume.cpp`
- `src/RcppExports.cpp` (generated by `Rcpp::compileAttributes()`)
- `tests/testthat/test_spectrahedron_volume.R`

## Notes / follow-ups

- The C++ part is currently a stub; follow-up work will swap in the real spectrahedra volume estimator behind the same entry point.
- Before pushing commits, double-check you’re not staging compiled artifacts (`.o`, `.a`) from `src/external/` builds.
